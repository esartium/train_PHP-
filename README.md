# Курс по PHP

PHP (Hypertext Preprocessor) - язык серверного функционала (js - язык клиентского функционала).

## База

#### Главный тег:

```
<?php
какой-то код
?>
```

Если в файле нет ничего, кроме php, закрывающий тег можно не писать.

#### Вывод информации:

```
echo "bebebe";
echo 'bababa';
```

Кавычки могут быть как двойные, так и одинарные (без разницы).

Помимо текста, можно также выводить html-объекты:

```
echo "<i>вывод html-штук</i>";
```

При этом в файле всё ещё может быть только php-код (не обязательно прописывать базовые штуки для html).

Перенос на новую строку делается с помощью html-тега ```<br>```.

Вывести с новой строки:

```
echo "что-то" . '<br>';
```

#### Комментарии

```
// коммент

# коммент

/* 
коммент
коммент
коммент
многострочный типа 
*/
```

## Переменные и типы данных

Переменные обозначаются через знак $ 

```
$peremennaya;
```

Вывод переменной:

```
echo "$per";
// или
echo $per;
```

Вывод двух переменных:
```
// Через два оператора echo:
echo $per;
echo $per2;
// или через один общий:
echo $per . $per2;
// С помощью точки мы объединяем несколько различных значений.
```

В переменной могут храниться не только целые числа:

```
$per = -5;

$per = 0.5;

$per = 'строка';

$per = true;
$per = false;
```

## Типы данных

В php для переменных не пишется тип данных, php сам распознаёт, какой это тип (нестрогая типизация).

Если сложить переменные
```
$per = 0.5;
$per1 = "0.5";
```
То данная операция обработается правильно. То есть мы можем складывать разные типы данных. Но так лучше не делать.

Также можно в одну переменную записать один тип данных, а потом, перобозначив её, записать в ту же самую переменную уже другой.

Функция, приводящая переменную другого типа данных к типу данных float:

```
floatval($per);
```

К типу int:

```
intval($per);
```

## В новых версиях php тип данных указывается при создании переменной!!

#### Константы

Консанта - как переменная, но значение константы даётся ей при инициализации и до конца программы не меняется.

Создать константу, используют функцию:

```
define(NAZVANIE, 35);
```

У этой функции два парамтера: 
+ название (его принято записывать в верхнем регистре)
+ само значение константы.

Вывод константы:

```
echo NAZVANIE;
```

## Математические действия

Между переменными можно делать все обычные операции: `+, -, ;, /, %`.

(% - остаток от деления)

Также можно применять операции к одной переменной, например, два способа увеличения значения переменной на число 10:

```
$x = $x + 10;
// или 
$x += 10;
```

Аналогично, можно совершать операции: `-=, *=, /=, %=`.

Если мы увеличиваем/уменьшаем число на 1, то можно также использовать:

```
$x++; //инкремент
//
$x--; //декремент
```

#### Встроенные константы

В php есть некоторые встроенные константы, например:

```
M_PI - это число пи
M_E - это число е
```

#### Встроенные математические фунции

+ Модуль:

```
echo abs(число);
```

(echo тут просто по приколу, для примера ситуации, а так не надо)

Функция abs вернёт либо число, если число, стоящее в качестве её аргумента, положительно; либо, если оно отрицательно - вернёт соответствующее положительное число.

+ Округление:

    + вверх:

    ```
    ceil(3.4);
    ```
    Эта функция выведет число 4;

    + вниз:

    ```
    floor(3.4);
    ```

    Эта функция выведет число 3;

    + по правилам математического округления:

    ```
    round(3.4);
    round(3.9);
    ```

    Здесь первая функция дала бы число 3, вторая - число 4;

    Другое применение функции round - оставить после точки определённое количество цифр:

    ```
    round(3.345466545643, 3);
    ```

    Здесь первый параметр - число, второй - количество нужных нам цифр после точки.

+ Тригонометрические функции:

```
sin();
cos();
tan();
```

+ Случайное число из указанного диапазона:

```
mt_rand(1, 20);
```

Данная функция выведет рандомное число от 1 до 20 (включительно). Число будет генерироваться при каждом обновлении страницы.

Поместить рандомное число в переменную:

```
$per = mt_rand(1, 20);
```

+ Минимальное число из указанного набора чисел:

```
min(3, 6, 8, 10);
```

+ Максимальное число из указанного набора чисел:

```
max(3, 6, 8, 10);
```

## Строки

Переменные можно вписывать внутрь строки текста:

```
echo "бла бла бла: $per";
```

Тогда переменная будет считаться переменной.

Если записать то же самое в одинарных кавычках:

```
echo 'бла бла бла: $per';
```

То всё написанное в этих одинарных кавычках будет считаться обычным текстом.

#### Вывод html-объектов

Пример:

```
// значения атрибутов указываются в одинарных кавычках
echo "<input type='text'>";
/* или в двойных, но нужно поставить \, чтобы показать, что кавычки - обычные символы, не несущие в себе никакого функционала */
echo "<input type=\"text\">";
```

#### Встроенные функции для работы со строками

+ strlen() - длина строки

```
$length = strlen($stroka);
```

+ Удаление всех пробелов до и после строки:

```
trim($stroka);
```

+ Перевод символов строки в нижний регистр:

```
strtolower();
```

Для кириллицы: 

```
mb_strtolower();
```

+ Перевод символов строки в верхний регистр:

```
strtoupper();
```

Для кириллицы: 

```
mb_strtoupper();
```

+ Можно в одном вызове вызвать сразу несколько функций (похоже на суперпозицию). Пример:

```
strtoupper(trim($stroka));
```

+ Захешировать строку:

```
md5($stroka);
```

Используется, например, для хранения паролей в базе данных.

## Условные операторы

Синтаксис - обычный, как и в других языках.

#### if

Пример:

```
if ($per45 == 45) {
    какое-то действие;
} 
```

#### Другие логические операции

Проверка не на равенство, а на остальные логические операции - аналогично другим языкам:

```
if ($per45 == 45) {
    какое-то действие;
} 

if ($per45 >= 45) {
    какое-то действие;
} 

if ($per45 <= 45) {
    какое-то действие;
} 

if ($per45 != 45) {
    какое-то действие;
} 

if ($per45 > 45) {
    какое-то действие;
} 

if ($per45 < 45) {
    какое-то действие;
} 
```

##### проверка на true/false:

+ Запись

```
if ($per == true) {
    ...;
}
```

эквивалентна записи:

```
if ($per) {
    ...;
}
```

+ Запись

```
if ($per == false) {
    ...;
}
```

эквивалентна записи:

```
if (!$per) {
    ...;
}
```

#### else

Оператор else - применяется как обычно (необязателен).

Пример:

```
if ($per45 == 45) {
    echo "Условный оператор" . '<br>';
} else {
    echo "ььььььььь " . '<br>';
}
```

#####

Если внутри условного оператора (if или else) только одна строчка кода, фигурные скобки можно не писать; если больше одной строчки, то фигурные скобки обязательны.

#### else if

else if - необязательный оператор; оператор else if находится между if и else; операторов else if может быть сколько угодно.

Пример:

```
if ($per45 + $per_rand >= 90) {
    echo "Условный оператор $per_rand" . '<br>';
} else if ($per45 + $per_rand >= 60) {
    echo "Условный оператор!!! $per_rand" . '<br>';
}
else {
    echo "условный оператор!! $per_rand" . '<br>';
}
```

#### Несколько условий

ИЛИ:

```
if (условие 1 || условие 2 || ... || условие n) {
    блаблабла;
}
```

И:

```
if (условие 1 && условие 2 && ... && условие n) {
    блаблабла;
}
```

#### Оператор Switch-case

Осуществляет роверку одной переменной на множество её значений.

Синтксис:

```
switch($проверяемая_переменная) {
    case конкретное_значение: 
        какое-то действие, если переменная принимает именно это значение;
        break; //это обязательно; означает конец этого условия (кейса)
    case другое_значение:
        какое-то действие, если переменная принимает именно это значение;
        break;
}
```

default - оператор, используемый, если ни один из кейсов (случаев) не подошёл. То есть, мы проверили все случаи, и они оказались неверны. Default похож на else; он не обязателен. Пишется в конце, после всех кейсов; break для него можно не писать, но можно и написать.

```
switch($проверяемая_переменная) {
    case конкретное_значение: 
        какое-то действие, если переменная принимает именно это значение;
        break; 
    case другое_значение:
        какое-то действие, если переменная принимает именно это значение;
        break;

    default: какое-то действие;
}
```

## Массивы данных

#### Создание массива:

```
$название = array(элементы через запятую; тут можно указать даже один элемент, и это всё равно удет считаться массивом);
```

Пример:

```
$massiv = array(2, 77, 142, -8);
```

Обращение к элементу массива:

```
$название_массива[индекс]
```

Индексация начинается с нуля.

#### Альтернативный способ создания массива

В php из-за нестрогой типизации в одном массиве могут храниться данные разных типов.

Альтернативный способ создания массива:

```
$название = [элементы через запятую; они могут быть любых типов];
```

Пример:

```
$arr = [12, 48, 1.2, 4.8, 'dfdgfd', false];
```

Работа с таким массивом происходит аналогично предыдущему пункту; обращение к элементам массива - так же, по индексу:

```
$arr[1]
```

#### Ассоциативные массивы

Здесь вместо индексов - ключи.

Пример:

```
$array = [
    "first_key" => "first_znachenie",
    "sec_key" => "sec_znachenie",
    "third_key" => "third_znachenie",
];
```

(Кавычки тут не потому что такой синтаксис, а потому что строки; тут также могут быть числа или булевые выражения, тогда кавычки не нужны).

Обращение к элементам массива осуществялется аналогично обращению по индексу, но здесь это делается по ключу, например:

```
$array["first_key"]
```

####  Многомерные массивы

В многомерных массивах каждый элемент - массив.

Создание многомерного массива:

```
$название = [
    [элементы первого массива через запятую],
    [элементы второго массива через запятую],
    [элементы третьего массива через запятую]
];
```

Пример:
```
$mass = [
    [1, 2, 3], [4, 5, 6], [765, 432, 219]
];
```

(Тут, очевидно, могут быть не только числа, но и любые другие типы)

Обращение к элементу многомерного массива:

```
$mass[индекс элемента-массива][индекс элемента массива]
```

Пример:

```
$mass[0][2] // здесь мы обратились к элементу с индексом 2 массива с индексом 0.
```

## Циклы

#### for

Синтаксис - обычный.

Примеры:

```
for ($i = 0; $i < 5; $i++) {
    echo $massiv[$i] . '_';
}
```

```
for ($i = 5; $i > 0; $i -= 2) {
    echo $massiv[$i] . '_';
}
```

#### While

Синтаксис - обычный.

Пример:

```
while ($i != 6) {
    echo $massiv[$i] . ' ыыы ';
    $i++;
}
```

```
$IsItTrue = true;
while($IsItTrue) {
        что-то;
    }
```

#### Do while

Как while, но do while вне зависимости от того, верно ли условие цикла, один раз выполнит действия из тела цикла, а потом уже будет проверять условия.

Пример:

```
$peremen = 1000;
do {
    echo $peremen . '<br>';
} while ($peremen < 10);
```

Здесь do while выполнит код из своего тела, и цикл остановится, потому что условие, указанное у while, неверное.

#### Операторы в циклах

+ оператор break - выйти из цикла в любой момент. 

Синтаксис:

```
for (условия) {
    if (условие)  
        break;
    
    какой-то код;
}
```

В такой ситуации для if НЕ НАДО ставить фигурные скобки (не будет работать).

+ оператор continue - пропуск одной итерации без выхода из цикла

То есть, после того, как мы наткнулись на continue, дальнейший код в этой итерации не выполняется, и начинается следующая итерация.

Пример:

```
for ($p = 100; $p > 10; $p /= 2) {
    if ($p < 50) 
        break;
    
    if ($p % 2 == 0) 
        continue;

    echo $p . '<br>';
}
```

Фигурные скобки здесь также не нужны - будет ошибка.

#### Вывод массива с помощью цикла

Как обычно. Пример:

```
for ($i = 0; $i < count($massiv); $i++) {
    echo "  элемент $i - " . $massiv[$i];
}
```

Здесь count(аргумент) - встроенная функция размера массива.

#### Вывод ассоциативного массива через foreach

```
// создадим массив:

$ar = [
    1 => "мяу",
    2 => "ыыы",
    3 => "бабаба",
    4 => "бебебе"
];

//выведем его:

foreach ($ar as $item => $value) {
    echo "Key: " . $item . ", value: " . $value . '<br>';
}
```
Здесь: 
+ ar - название массива
+ item - переменная для ключей, value - переменная для значений (могут называться как угодно, просто добно, когда наглядно)
+ В теле записано, что нам нужно вывести ключ и значение каждого элемента ассоциативного массива.

#### Вывод обычного одномерного массива через foreach

```
foreach ($massiv as $value) {
    echo $value . '<br>';
}
```

## Функции

Синтаксис:

Создание функции: 

```
function название (параметры, переданные в функцию, если они есть) {
    тело функции;
}
```

Функция выполняется только после вызова.

Синтаксис вызова функции:

```
название_функции(параметры, переданные в функцию, если они есть);
```

Если парамтеров у функции больше одного, они просто перечисляются через запятую.

Передача конкретных параметров при вызове (пример):

```
function twopar ($x, $y) {
    $res = $x / $y;
    echo $res . '<br>';
}

twopar(10, 5);
```

Внутри тела функции можно вызывать другие функции.

#### Возвращение значений

Это делается с помощью ключевого слова return.

Пример:

```
function twopar2 ($x, $y) {
    $res = $x / $y;
    return $res;
}
```

То же самое, но по-другому:

```
function twopar2 ($x, $y) {
    return $x / $y;
}
```

Запись результата функции в переменную, пример:

```
$res2 = twopar2(3, 1);
```

Теперь с ней можно производить различные действия, например, также передать в качестве параметра какой-нибудь функции при её вызове:

```
vivod($res2);
```

#### Область видимости

```
function название () {
    $x = 0;
}

$x = 100;
```

Здесь первый x - локальная переменная (видна только внутри функции), второй - глобальная; по сути, это две разные переменные, которые никак между собой не пересекаются.

Чтобы обратитиься к глобальной переменной внутри функции, пишем ключевое слово global:

```
function название () {
    global $x;
    echo $x;
}
```

## Динамическое подключение файлов

#### require

```
<?php 
require "путь к файлу";
?>

какой-нибудь html .....

<?php 
require "путь к ещё какому-нибудь файлу";
?>
```

При использовании require мы на самом деле просто вставляем код из файла туда, где вызываем require. (просто не видим этого)

Файлы, которые мы так подключаем, могут состоять из html, но они всё равно имеют расширение php.

Если в require есть какая-то ошибка (например, попытка подключить несуществующий файл), то весь код, идущий после require, выполняться не будет.

#### include

Если в include есть какая-то ошибка, то весь код, идущий после require, выполнится.

```
<?php 
include "путь к файлу";
?>
```

#### include_once и require_once

Если мы попытаемся два раза подключить один и тот же файл таким способом, он подключится только один раз.

#### Передача данных из "главного" файла в те, которые к нему подключены:

https://www.youtube.com/watch?v=PnJth5WMqpQ&list=PLDyJYA6aTY1m5zGQVcEYIoSFz2GD8u7cC&index=11

## Обработка форм

Урок из курса:
https://www.youtube.com/watch?v=vWtFwiRBqcg&list=PLDyJYA6aTY1m5zGQVcEYIoSFz2GD8u7cC&index=12

Примеры в папке train.

# ООП в php

### Классы 

В классе одновременно хранятся как фиксированные значения (переменные простых типов данных, массивы), так и динамичные (функции). Переменные класса называются свойствами, функции класса - методами.

#### Создание класса:

#####

Общая структура проекта:
+ папка, где лежит весь проект
    + папка, где лежит основной файл index.php
    + папка, где лежат файлы классов

#####

Делаем отдельный файл, который называется так же, как сам класс (пример структуры проекта смотри в train проекте). Названия классов пишутся с большой буквы. 

Пример:

```
class Worker 
{
    //Свойства:

    public string $name;
    public int $age;
    public array $hours;

    //Методы:

    public function work() {
        
    }
}
```

### Создание объекта:

Объект создаётся в главном файле php. В него мы подключаем файл, где прописывали класс.

Синтаксис:

```
//подключение файла класса:
require_once('путь к файлу класса');

//создание объекта (засунули его в переменную):
$какая-то_переменная = new Название_класса();
```

### Autoload

Чтобы не подключать миллион файлов с классами, используется autoload.

Для этого создаётся файл composer.json

```
{
    "autoload": {
        "psr-4": {
            "Название1\\":"название_папки_с_классами/"
        }
    }
}
```

Здесь Название1 - это тоже название папки, где лежат файлы с классами, но с большой буквы.

Теперь в терминале напишем `commposer install`. У нас появилась папка vendor, в которой находится файл autoload.php; его нам и нужно будет подключить в главный php-файл проекта (тот, где мы пишем весь код, и куда изначально хотели подключать кучу файлов с классами).

Также внутри файла класса нужно прописать `namespace Название1`.

И теперь, когда в главном файле мы будем создавать объект класса, текстовый редактор будет сам писать буквы для подключения, которые до этого мы бы писали самостоятельно.

В VS Code эти буквы будут выглядеть так:

```
<?php 
use App\Worker; //вот эти буквы

require_once('../vendor/autoload.php');

$worker = new Worker;
```

####

Как вызвать метод класса для объекта класса:

```
$объект->метод();
```

### Конструктор

Синтаксис:

```
public function __construct(параметры) {
        тело функции;
    }
```

Параметры будут так же переданы объекту при его создании.

Пример:

```
public function __construct($name, $age, $hours) {
        $this->name = $name;
        $this->age = $age;
        $this->hours = $hours;
    }
```

`$this` - указатель на самого себя.
(То есть, на сам этот конкретный объект)

### Наследование

Пусть класс 1 был создан первым, а класс 2 его наследует.

Тогда при создании класса 2 в его файле пишем:

```
class название_класса_2 extends название_родительского_класса {
    тело класса
}
```

### Геттеры и сеттеры

Используются, чтобы иметь досуп к private переменным.

#### Сеттер

Сеттер нужен, чтобы устнаовить значение для приватной переменной.

Синтаксис:

(внтури тела класса)
```
public function setНазвание($value) {
    $this->название = $value;
}
```

#### Геттер

Геттер нужен, чтобы получить значение приватной переменной.

Синтаксис:

(внтури тела класса)
```
public function getНазвание():string {
    return $this->название;
}
```

Здесь string - тип данных, который вернёт нам геттер (это как пример, тут могут быть и другие типы)

### Абстрактные классы

Классы, от которых нельзя создать объект.

Синтаксис:

```
abstract class Название 
{
    тело;
}
```

Но от них могут быть унаследованы другие классы.

### Статические методы и свойства

Статическая функция, обьявленная в классе, позволяет обратиться к классу, не создавая конкретных обьектов класса.

Синтаксис:

```
static public function название(аргументы, если есть) {
    тело;
}
```




